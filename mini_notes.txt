MINITALTK NOTES

struct sigaction

sigaction() function allows the calling process to examine and/or specify the action to be assigned to a specified signal.
sig specifies the used signal.

sigaction {
               void     (*sa_handler)(int);
               void     (*sa_sigaction)(int, siginfo_t *, void *);
               sigset_t   sa_mask;
               int        sa_flags;
               void     (*sa_restorer)(void);
           };

Occupied storage by sa_handler and sa_sigaction may overlap, an application cannot use it simultaneously.

Argument act points to structure specifying the action to be associated with specified signal.
The action previously associated with the signal is stored in the location pointed to by the argument oact.


SIGUSR1 & SIGUSR2 -> signals set aside by you to be used as you want; they're useful for interprocess communication if you write a signal handler for them in the program that receives signal.
Default action is to terminate the process.


struct siginfo
siginfo_t {
               int      si_signo;     /* Signal number */
               int      si_errno;     /* An errno value */
               int      si_code;      /* Signal code */
               int      si_trapno;    /* Trap number that caused
                                         hardware-generated signal
                                         (unused on most architectures) */
               pid_t    si_pid;       /* Sending process ID */
               uid_t    si_uid;       /* Real user ID of sending process */
               int      si_status;    /* Exit value or signal */
               clock_t  si_utime;     /* User time consumed */
               clock_t  si_stime;     /* System time consumed */
               union sigval si_value; /* Signal value */
               int      si_int;       /* POSIX.1b signal */
               void    *si_ptr;       /* POSIX.1b signal */
               int      si_overrun;   /* Timer overrun count;
                                         POSIX.1b timers */
               int      si_timerid;   /* Timer ID; POSIX.1b timers */
               void    *si_addr;      /* Memory location which caused fault */
               long     si_band;      /* Band event (was int in
                                         glibc 2.3.2 and earlier) */
               int      si_fd;        /* File descriptor */
               short    si_addr_lsb;  /* Least significant bit of address
                                         (since Linux 2.6.32) */
               void    *si_lower;     /* Lower bound when address violation
                                         occurred (since Linux 3.19) */
               void    *si_upper;     /* Upper bound when address violation
                                         occurred (since Linux 3.19) */
               int      si_pkey;      /* Protection key on PTE that caused
                                         fault (since Linux 4.6) */
               void    *si_call_addr; /* Address of system call instruction
                                         (since Linux 3.5) */
               int      si_syscall;   /* Number of attempted system call
                                         (since Linux 3.5) */
               unsigned int si_arch;  /* Architecture of attempted system call
                                         (since Linux 3.5) */
           }


sa_siginfo tells the system to use the signal action specified by sa_sigaction instead of sa_handler.


sigemptyset() --> initializes a signal set to the empty set; all recognized signals are excluded  


int kill(pid_t pid, int sig)
function is used to send a signal to another process or group of processes specified by pid. signal sent is specified by the signal and is one from the list given in signal.h or 0: the latter permits to error check but no signal is sent. (useful to check pid validity).
if pid > 0 sig shall be sent to the process whose process ID is equal to pid.
fill() is successful if the process has permission to send sig to any process specified by pid. if kill() fails no signal shall be sent.
return value success -> 0 return value unsuccess -> -1


sigaction() specifies more info than signal(). return value from signal cannot express the full range of sigaction possibilities.
If you use signal() to save and later reestablish an action, it may not be able to reestablish properly a handler that was established with sigaction().
Since sigaction() is more general it can properly save and reestablish any action, either way if it was set by signal or sigaction.
Signal() may not be versatile between different distros.

